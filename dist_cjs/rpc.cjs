"use strict";var ze=Object.create;var le=Object.defineProperty;var Je=Object.getOwnPropertyDescriptor;var He=Object.getOwnPropertyNames;var Xe=Object.getPrototypeOf,Qe=Object.prototype.hasOwnProperty;var o=(t,e)=>le(t,"name",{value:e,configurable:!0});var Ye=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of He(e))!Qe.call(t,i)&&i!==r&&le(t,i,{get:()=>e[i],enumerable:!(n=Je(e,i))||n.enumerable});return t};var Ze=(t,e,r)=>(r=t!=null?ze(Xe(t)):{},Ye(e||!t||!t.__esModule?le(r,"default",{value:t,enumerable:!0}):r,t));Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const fe=[new Map,new Map];function L(t){return function(e){const[r,n]=fe;r.set(t,e),n.set(e,t)}}o(L,"RpcCustomError");var Oe=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function et(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}o(et,"getDefaultExportFromCjs");var Me={exports:{}},ue={exports:{}},Ce;function tt(){return Ce||(Ce=1,function(t,e){(function(r,n){t.exports=n()})(Oe,function(){function r(f){return!isNaN(parseFloat(f))&&isFinite(f)}o(r,"_isNumber");function n(f){return f.charAt(0).toUpperCase()+f.substring(1)}o(n,"_capitalize");function i(f){return function(){return this[f]}}o(i,"_getter");var s=["isConstructor","isEval","isNative","isToplevel"],c=["columnNumber","lineNumber"],l=["fileName","functionName","source"],a=["args"],b=["evalOrigin"],u=s.concat(c,l,a,b);function h(f){if(f)for(var p=0;p<u.length;p++)f[u[p]]!==void 0&&this["set"+n(u[p])](f[u[p]])}o(h,"StackFrame"),h.prototype={getArgs:function(){return this.args},setArgs:function(f){if(Object.prototype.toString.call(f)!=="[object Array]")throw new TypeError("Args must be an Array");this.args=f},getEvalOrigin:function(){return this.evalOrigin},setEvalOrigin:function(f){if(f instanceof h)this.evalOrigin=f;else if(f instanceof Object)this.evalOrigin=new h(f);else throw new TypeError("Eval Origin must be an Object or StackFrame")},toString:function(){var f=this.getFileName()||"",p=this.getLineNumber()||"",N=this.getColumnNumber()||"",z=this.getFunctionName()||"";return this.getIsEval()?f?"[eval] ("+f+":"+p+":"+N+")":"[eval]:"+p+":"+N:z?z+" ("+f+":"+p+":"+N+")":f+":"+p+":"+N}},h.fromString=o(function(p){var N=p.indexOf("("),z=p.lastIndexOf(")"),Ge=p.substring(0,N),Ke=p.substring(N+1,z).split(","),ve=p.substring(z+1);if(ve.indexOf("@")===0)var ce=/@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(ve,""),We=ce[1],Ve=ce[2],qe=ce[3];return new h({functionName:Ge,args:Ke||void 0,fileName:We,lineNumber:Ve||void 0,columnNumber:qe||void 0})},"StackFrame$$fromString");for(var g=0;g<s.length;g++)h.prototype["get"+n(s[g])]=i(s[g]),h.prototype["set"+n(s[g])]=function(f){return function(p){this[f]=!!p}}(s[g]);for(var d=0;d<c.length;d++)h.prototype["get"+n(c[d])]=i(c[d]),h.prototype["set"+n(c[d])]=function(f){return function(p){if(!r(p))throw new TypeError(f+" must be a Number");this[f]=Number(p)}}(c[d]);for(var w=0;w<l.length;w++)h.prototype["get"+n(l[w])]=i(l[w]),h.prototype["set"+n(l[w])]=function(f){return function(p){this[f]=String(p)}}(l[w]);return h})}(ue)),ue.exports}o(tt,"requireStackframe");(function(t,e){(function(r,n){t.exports=n(tt())})(Oe,o(function(n){var i=/(^|@)\S+:\d+/,s=/^\s*at .*(\S+:\d+|\(native\))/m,c=/^(eval@)?(\[native code])?$/;return{parse:o(function(a){if(typeof a.stacktrace<"u"||typeof a["opera#sourceloc"]<"u")return this.parseOpera(a);if(a.stack&&a.stack.match(s))return this.parseV8OrIE(a);if(a.stack)return this.parseFFOrSafari(a);throw new Error("Cannot parse given Error object")},"ErrorStackParser$$parse"),extractLocation:o(function(a){if(a.indexOf(":")===-1)return[a];var b=/(.+?)(?::(\d+))?(?::(\d+))?$/,u=b.exec(a.replace(/[()]/g,""));return[u[1],u[2]||void 0,u[3]||void 0]},"ErrorStackParser$$extractLocation"),parseV8OrIE:o(function(a){var b=a.stack.split(`
`).filter(function(u){return!!u.match(s)},this);return b.map(function(u){u.indexOf("(eval ")>-1&&(u=u.replace(/eval code/g,"eval").replace(/(\(eval at [^()]*)|(,.*$)/g,""));var h=u.replace(/^\s+/,"").replace(/\(eval code/g,"(").replace(/^.*?\s+/,""),g=h.match(/ (\(.+\)$)/);h=g?h.replace(g[0],""):h;var d=this.extractLocation(g?g[1]:h),w=g&&h||void 0,f=["eval","<anonymous>"].indexOf(d[0])>-1?void 0:d[0];return new n({functionName:w,fileName:f,lineNumber:d[1],columnNumber:d[2],source:u})},this)},"ErrorStackParser$$parseV8OrIE"),parseFFOrSafari:o(function(a){var b=a.stack.split(`
`).filter(function(u){return!u.match(c)},this);return b.map(function(u){if(u.indexOf(" > eval")>-1&&(u=u.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,":$1")),u.indexOf("@")===-1&&u.indexOf(":")===-1)return new n({functionName:u});var h=/((.*".+"[^@]*)?[^@]*)(?:@)/,g=u.match(h),d=g&&g[1]?g[1]:void 0,w=this.extractLocation(u.replace(h,""));return new n({functionName:d,fileName:w[0],lineNumber:w[1],columnNumber:w[2],source:u})},this)},"ErrorStackParser$$parseFFOrSafari"),parseOpera:o(function(a){return!a.stacktrace||a.message.indexOf(`
`)>-1&&a.message.split(`
`).length>a.stacktrace.split(`
`).length?this.parseOpera9(a):a.stack?this.parseOpera11(a):this.parseOpera10(a)},"ErrorStackParser$$parseOpera"),parseOpera9:o(function(a){for(var b=/Line (\d+).*script (?:in )?(\S+)/i,u=a.message.split(`
`),h=[],g=2,d=u.length;g<d;g+=2){var w=b.exec(u[g]);w&&h.push(new n({fileName:w[2],lineNumber:w[1],source:u[g]}))}return h},"ErrorStackParser$$parseOpera9"),parseOpera10:o(function(a){for(var b=/Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,u=a.stacktrace.split(`
`),h=[],g=0,d=u.length;g<d;g+=2){var w=b.exec(u[g]);w&&h.push(new n({functionName:w[3]||void 0,fileName:w[2],lineNumber:w[1],source:u[g]}))}return h},"ErrorStackParser$$parseOpera10"),parseOpera11:o(function(a){var b=a.stack.split(`
`).filter(function(u){return!!u.match(i)&&!u.match(/^Error created at/)},this);return b.map(function(u){var h=u.split("@"),g=this.extractLocation(h.pop()),d=h.shift()||"",w=d.replace(/<anonymous function(: (\w+))?>/,"$2").replace(/\([^)]*\)/g,"")||void 0,f;d.match(/\(([^)]*)\)/)&&(f=d.replace(/^[^(]+\(([^)]*)\)$/,"$1"));var p=f===void 0||f==="[arguments not available]"?void 0:f.split(",");return new n({functionName:w,args:p,fileName:g[0],lineNumber:g[1],columnNumber:g[2],source:u})},this)},"ErrorStackParser$$parseOpera11")}},"ErrorStackParser"))})(Me);var rt=Me.exports;const te=et(rt);function he(t){return t.replaceAll("\r","").replaceAll(/^\n+|\n+$/g,"").replaceAll(/^  +/gm,"	")}o(he,"fixString");function re(t){let e="";for(let r of t){if(r.functionName?.includes("$RPC_MARKER_BEGIN$"))break;e+=`
	at `+r}return e}o(re,"framesToString");function Fe(t){return t===void 0?"":t instanceof m?`
caused by: `+t.toString():t instanceof Error?`
caused by: `+he(t.toString())+re(te.parse(t))+Fe(t.cause):`
caused by: `+he(t?.toString()??"null")}o(Fe,"causeToString");function Te(t,e){return(t===m||Te(t.__proto__,e))&&e[0].functionName?.replace(/^new /,"")===t.name?(e.shift(),!0):!1}o(Te,"removeFromStackTrace");class m extends Error{static{o(this,"RpcError")}from;data={};#t=[];get stackTrace(){let e=this.#e;return e+=re(this.#t),e+=this.#n,e.replaceAll(/^\n+/g,"")}#e="";#r=!1;#n="";constructor(...e){let r=null,n=null,i=null,s={},c;switch(e.length){case 1:[n]=e;break;case 2:[n,c]=e;break;case 4:[n,r,n,i]=e;break;case 5:e[4]instanceof m?[n,r,n,i,c]=e:[n,r,n,i,s]=e;break;case 6:[n,r,n,i,s,c]=e;break;default:throw new Error("Invalid arg count")}c!=null?super(n??void 0,{cause:c}):super(n??void 0),this.name=this.constructor.name,this.from=r??C.prettyName;const l=fe[1].get(this.constructor);if(l!=null&&(this.data.$type=l),Object.assign(this.data,s??{}),i==null)this.#r=!0,this.#t=te.parse(this),Te(this.constructor,this.#t);else{this.#e=`
`+he(i);const a=this.#e.indexOf(`
caused by: `);a!=-1&&(this.#n+=this.#e.substring(a),this.#e=this.#e.substring(0,a))}this.#n+=Fe(c),this.stack=this.toString()}toString(){let e=this.name+"("+this.from+")";this.message?.trim()&&(e+=": "+this.message);const r=this.stackTrace;return r?.trim()&&(e+=`
`+r),e}write(e){e.writeString(this.name),e.writeString(this.from),e.writeString(this.message),e.writeString(this.stackTrace),e.writeString(Object.keys(this.data).length==0?null:JSON.stringify(this.data))}static read(e){const r=e.readString(),n=e.readString()??"???",i=e.readString(),s=e.readString()??"";let c;try{c=JSON.parse(e.readString()??"null")}catch(l){if(l instanceof RangeError)c={$info:"JsonData was not included, due to an old PlayifyRpc version"};else throw l}return m.create(r,n,i,s,c)}static create(e,r,n,i,s){const c=s?.$type,l=fe[0].get(c)??m;return new l(e,r,n,i,s)}static wrapAndFreeze(e){return e instanceof m?(e.#r&&(e.#r=!1,e.#e+=re(e.#t),e.#t=[],e.stack=e.toString()),e):new m(e.name,e instanceof m?e.from:null,e.message,re(te.parse(e)).substring(1),{},e.cause)}unfreeze(e,r){return this.#r?this:(this.#r=!0,this.#t=te.parse(e).slice(r),this.stack=this.toString(),this)}trashLocalStack(){return this.#r=!1,this.#t=[],this.stack=this.toString(),this}append(e,r,n){return this.#e+=`
	rpc `+(n==null?"<<callLocal>>":(e??"<<null>>")+"."+(r??"<<null>>")+"("+n.map(i=>JSON.stringify(i)).join(",")+")"),this.stack=this.toString(),this}}const xe=globalThis?.process?.versions?.node!=null,Se="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",ge=o(()=>Date.now().toString(36)+Array(10).fill(void 0).map(()=>Se[Math.floor(Math.random()*Se.length)]).join(""),"randomId");let R;if(xe)try{process?.versions.bun?R="bun@"+require("os").hostname()+"@"+process.pid:R="node@"+process.binding("os").getHostname()+"@"+process.pid}catch{R="node-alternative@"+process.platform+":"+process.arch+"@"+process.pid}else"document"in globalThis?R="web@"+document.location+"#"+ge():R="js@"+ge();var Le=Object.defineProperty,nt=Object.getOwnPropertyDescriptor,it=o((t,e,r)=>e in t?Le(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,"__defNormalProp"),V=o((t,e,r,n)=>{for(var i=n>1?void 0:n?nt(e,r):e,s=t.length-1,c;s>=0;s--)(c=t[s])&&(i=(n?c(e,r,i):c(i))||i);return n&&i&&Le(e,r,i),i},"__decorateClass"),Y=o((t,e,r)=>(it(t,typeof e!="symbol"?e+"":e,r),r),"__publicField");const H=o(t=>t==null?"null":'"'+t+'"',"quoted");class q extends m{static{o(this,"RpcCallError")}}exports.RpcTypeNotFoundError=class extends q{static{o(this,"RpcTypeNotFoundError")}};Y(exports.RpcTypeNotFoundError,"new",t=>new exports.RpcTypeNotFoundError(null,null,`Type ${H(t)} does not exist`,"",{type:t}));exports.RpcTypeNotFoundError=V([L("$type")],exports.RpcTypeNotFoundError);exports.RpcMethodNotFoundError=class extends q{static{o(this,"RpcMethodNotFoundError")}};Y(exports.RpcMethodNotFoundError,"new",(t,e)=>new exports.RpcMethodNotFoundError(null,null,`Method ${H(e)} does not exist on type ${H(t)}`,"",{type:t,method:e}));exports.RpcMethodNotFoundError=V([L("$method")],exports.RpcMethodNotFoundError);exports.RpcMetaMethodNotFoundError=class extends exports.RpcMethodNotFoundError{static{o(this,"RpcMetaMethodNotFoundError")}};Y(exports.RpcMetaMethodNotFoundError,"new",(t,e)=>new exports.RpcMetaMethodNotFoundError(null,null,`Meta-Method ${H(e)} does not exist on type ${H(t)}`,"",{type:t,method:null,meta:e}));exports.RpcMetaMethodNotFoundError=V([L("$method-meta")],exports.RpcMetaMethodNotFoundError);exports.RpcConnectionError=class extends q{static{o(this,"RpcConnectionError")}};Y(exports.RpcConnectionError,"new",t=>new exports.RpcConnectionError(null,null,t,""));exports.RpcConnectionError=V([L("$connection")],exports.RpcConnectionError);exports.RpcEvalError=class extends q{static{o(this,"RpcEvalError")}};exports.RpcEvalError=V([L("$eval")],exports.RpcEvalError);exports.RpcDataError=class extends m{static{o(this,"RpcDataError")}};Y(exports.RpcDataError,"new",(t,e)=>new exports.RpcDataError(null,null,t,"",e));exports.RpcDataError=V([L("$data")],exports.RpcDataError);function st(t){let e=t.toString();e=e.substring(e.indexOf("(")+1);const r=[];for(;;){const n=M(e);for(r.push(n.replaceAll("\0","").trim()),e=e.substring(n.length);e[0]=="/";)e=e.substring(M(e).length);for(e[0]=="="&&(e=e.substring(M(e.substring(1)).length+1));e[0]=="/";)e=e.substring(M(e).length);if(e[0]==")")break;if(e[0]==",")e=e.substring(1);else throw new Error("Invalid args")}return r}o(st,"getFunctionParameterNames");function M(t){if(t[0]=="/"){if(t[1]=="/"){const e=t.indexOf(`
`);return e==-1?t:t.substring(0,e+1)}if(t[1]=="*"){const e=t.indexOf("*/",2);return e==-1?t:t.substring(0,e+2)}}if(t[0]=="["){let e="[";for(;;){if(e+=M(t.substring(e.length)),t[e.length]=="]")return e+"]";if(t[e.length]==",")e+=",";else{if(t[e.length]=="/")continue;if(t[e.length]=="=")e+="\0".repeat(M(t.substring(e.length+1)).length+1);else throw new Error("Invalid array destructuring")}}}if(t[0]=="{"){let e="{";for(;;){if(e+=M(t.substring(e.length)),t[e.length]=="}")return e+"}";if(t[e.length]==":")e+=":";else if(t[e.length]==",")e+=",";else{if(t[e.length]=="/")continue;if(t[e.length]=="=")e+="\0".repeat(M(t.substring(e.length+1)).length+1);else throw new Error("Invalid object destructuring")}}}if(t[0]=='"'||t[0]=="'"||t[0]=="`"){for(let e=1;e<t.length;e++){if(t[e]==t[0])return t.substring(0,e+1);if(t[e]=="\\")switch(t[e+1]){case"u":e+=5;break;case"x":e+=3;break;default:e+=1;break}}throw new Error("Missing end of string")}for(let e=0;e<t.length;e++)if(t[e]==","||t[e]=="]"||t[e]=="}"||t[e]==")"||t[e]=="=")return t.substring(0,e);return t}o(M,"identifier");const ot="1.5.1",be=Object.create(null),S=new Map;S.set("$"+R,be);function at(){return"$"+R+"$"+ge()}o(at,"generateTypeName");async function $e(t,e){if(!S.has(t)){S.set(t,e);try{j&&await y(null,"+",t)}catch(r){console.error(`[Rpc] Error registering type "${t}":`,r),S.delete(t)}}}o($e,"registerType");async function ct(t){if(S.has(t)){try{j&&await y(null,"-",t)}catch(e){console.error(`[Rpc] Error unregistering type "${t}":`,e)}S.delete(t)}}o(ct,"unregisterType");async function Pe(t,e,r,...n){if(r!=null){let s=t[r];if(s==null){let l=(await _e(t)).find(a=>a.toLowerCase()==r.toLowerCase());l!=null&&(s=t[l])}const c={}[r];if(s==null||s===c)throw exports.RpcMethodNotFoundError.new(e,r);try{return await{async $RPC_MARKER_BEGIN$(){return await s.call(t,...n)}}.$RPC_MARKER_BEGIN$()}catch(l){throw m.wrapAndFreeze(l)}}const i=n.length==0?null:n[0];switch(i){case"M":return _e(t);case"S":return lt(t,e,n[1]==null?null:""+n[1],!!n[2]);case"V":return ut(t);default:throw exports.RpcMetaMethodNotFoundError.new(e,i)}}o(Pe,"invoke");async function lt(t,e,r,n){if(r==null)return[[["M"],"string[]"],[["S",n?"method:string|null":"string? method",n?"ts:boolean":"bool ts"],n?"[parameters:string[],returns:string][]":"(string[] parameters,string @return)[]"],[["V"],"string"]];const i=t[J];if(i)return await i.call(t,r,n);const s=t[r];if(!s)throw new exports.RpcMethodNotFoundError(e,r);return s[J]?s[J].call(s,n):[[st(s),n?"unknown":"object?"]]}o(lt,"getMethodSignatures");async function _e(t){const e=t[W];return e?await e.call(t):Object.getOwnPropertyNames(t).filter(r=>typeof t[r]=="function")}o(_e,"getMethods");async function ut(t){const e=t[Q];return e?await e.call(t):ot+" JS"}o(ut,"getRpcVersion");class se{static{o(this,"PendingCall")}[Symbol.toStringTag]="PendingCall";finished=!1;promise;constructor(e,r){try{throw new Error}catch(n){this.promise=new Promise((i,s)=>{A.set(this,c=>{A.delete(this),v.delete(this),this.finished=!0,i(c),ne(r)}),v.set(this,c=>{A.delete(this),v.delete(this),this.finished=!0,s(c instanceof m?c.unfreeze(n,e):c),ne(r)})})}}catch(e){return this.promise.catch(e)}finally(e){return this.promise.finally(e)}then(e,r){return this.promise.then(e,r)}sendMessage(...e){return this}addMessageListener(e){return ee(this,e)}cancel(){}getCaller(){return Promise.resolve(C.prettyName)}[Symbol.asyncIterator](){return Z(this)}}function Z(t){let e=[],r=[];return t.promise.catch(()=>{}),t.promise.finally(()=>{for(let n of r)n({done:!0,value:void 0})}),t.addMessageListener((...n)=>{(r.shift()??e.push)({done:!1,value:n})}),{async next(){return t.finished?{done:!0,value:void 0}:e.shift()??await new Promise(n=>r.push(n))}}}o(Z,"getAsyncIterator");const A=new WeakMap,v=new WeakMap,P=new WeakMap,k=new WeakMap;function ee(t,e){if(k.has(t))k.get(t).push(e);else{k.set(t,[e]);const r=P.get(t)??[];for(let n of r)try{e(...n)}catch(i){console.warn("[Rpc] Error while handling pending message:",i)}}return t}o(ee,"registerReceive");function K(t,e){if(!t.finished)if(k.has(t))for(let r of k.get(t))try{r(...e)}catch(n){console.warn("[Rpc] Error while receiving message:",n)}else P.has(t)?P.set(t,[...P.get(t),e]):P.set(t,[e])}o(K,"runReceiveMessage");let F=null;function ft(t,e){const r=F;F=e;try{return t()}finally{F=r}}o(ft,"runWithContext");function ht(){if(F==null)throw new Error("FunctionCallContext not available");return F}o(ht,"getFunctionContext");let gt=0;function y(t,e,...r){if(t!=null){const l=S.get(t);if(l)return Ae(Pe.bind(null,l,t,e,...r),t,e,r,3)}const n=[],i=new se(2,n),s=new x,c=gt++;try{s.writeByte(E.FunctionCall),s.writeLength(c),s.writeString(t),s.writeString(e),s.writeArray(r,l=>s.writeDynamic(l,n))}catch(l){return v.get(i)?.(l),i}return j||t==null&&G!=null?(i.sendMessage=(...l)=>{if(i.finished)return i;const a=new x;a.writeByte(E.MessageToExecutor),a.writeLength(c);const b=[];return a.writeArray(l,u=>a.writeDynamic(u,b)),n.push(...b),U(a),i},i.cancel=()=>{if(i.finished)return;const l=new x;l.writeByte(E.FunctionCancel),l.writeLength(c),U(l)},i.getCaller=()=>y(null,"c",c),yt(c,i,s),i):(v.get(i)?.(exports.RpcConnectionError.new("Not connected")),i)}o(y,"callRemoteFunction");function dt(t){return Ae(t,null,null,null,3)}o(dt,"callLocal");function Ae(t,e,r,n,i){const s=new se(i,[]),c=new AbortController,l={type:e,method:r,sendMessage:(...a)=>(s.finished||K(s,a),l),get finished(){return s.finished},promise:s,addMessageListener:a=>ee(l,a),cancelToken:c.signal,cancelSelf:()=>c.abort(),[Symbol.asyncIterator]:()=>Z(l)};return s.sendMessage=(...a)=>(s.finished||K(l,a),s),s.cancel=()=>s.finished||l.cancelSelf(),ke(t,l,A.get(s),v.get(s),e,r,n),s}o(Ae,"callLocalFunction");async function ke(t,e,r,n,i,s,c){try{let l;const a=F;F=e;try{l=await{async $RPC_MARKER_BEGIN$(){return await t()}}.$RPC_MARKER_BEGIN$()}finally{F=a}r?.(await l)}catch(l){n?.(m.wrapAndFreeze(l).append(i,s,c))}}o(ke,"invokeForPromise");const _=class extends o(function(r){return Object.setPrototypeOf(r,new.target.prototype)},"Extendable"){static{o(this,"RpcFunction2")}constructor(e,r){super(y.bind(null,e,r)),this.type=e,this.method=r}async getMethodSignatures(e=!1){return y(this.type,null,"S",this.method,e)}toString(){return`rpc (...params) => ${this.type??"null"}.${this.method}(...params)`}};let pt=Date.now();const de=new WeakMap;function oe(t){if(t instanceof _)return t;const e=de.get(t);if(e!=null)return new _("$"+R,e);const r=(pt++).toString(16);be[r]=t,de.set(t,r);const n="$"+R;return new _(n,r)}o(oe,"registerFunction");function ae(t){const e="$"+R;if(t.type!=e)throw new Error("Can't unregister RemoteFunction, that was not registered locally");delete be[t.method],de.delete(t)}o(ae,"unregisterFunction");const T=Symbol("RpcObjectType"),X=Symbol("RpcObjectExists"),W=Symbol("RpcObjectGetMethods"),J=Symbol("RpcObjectGetMethodSignatures"),Q=Symbol("RpcObjectGetRpcVersion");function I(t,e=new class{static{o(this,"RpcObject")}[T]=t}){const r=new Map;return new Proxy(e,{get(n,i){if(i==T)return t;if(i==X)return()=>y(null,"E",t);if(i==W)return()=>y(t,null,"M");if(i==Q)return()=>y(t,null,"V");if(typeof i!="string"||i=="then")return e[i];if(r.has(i))return r.get(i);const s=new _(t,i);return r.set(i,s),s},construct(n,i){return new n(...i)},has(n,i){return i==T||i==W||i==X||i==Q||i in e}})}o(I,"createRemoteObject");const me=new Proxy({},{get:(t,e)=>typeof e=="string"?I(e):void 0,has:(t,e)=>typeof e=="string"&&e!="then"}),Ie=[],je=new Map;function pe(t,e){let r=t.readLength();if(r<0){switch(r=-r,r%4){case 0:return e[r/4];case 1:return new TextDecoder().decode(t.readBuffer((r-1)/4));case 2:{const n={};e.push(n);for(let i=0;i<(r-2)/4;i++){const s=t.readString();n[s]=pe(t,e)}return n}case 3:{const n=new Array((r-3)/4);e.push(n);for(let i=0;i<n.length;i++)n[i]=pe(t,e);return n}}throw new Error("Unreachable code reached")}else if(r>=128){const n=new TextDecoder().decode(t.readBuffer(r-128)),i=je.get(n);if(i)return i(t,e);throw new Error("Unknown data type: "+n)}else switch(String.fromCodePoint(r)){case"n":return null;case"t":return!0;case"f":return!1;case"i":return t.readInt();case"d":return t.readDouble();case"l":return t.readLong();case"b":return t.readBuffer(t.readLength());case"D":return new Date(Number(t.readLong()));case"R":{const l=t.readString(),a=t.readByte();return new RegExp(l,"g"+(a&1?"i":"")+(a&2?"m":""))}case"E":return t.readError();case"O":const n=t.readString();if(n==null)throw new Error("Type can't be null");return I(n);case"F":const i=t.readString();if(i==null)throw new Error("Type can't be null");const s=t.readString();if(s==null)throw new Error("Method can't be null");const c=new _(i,s);return e.push(c),c;default:throw new Error("Unknown data type number: "+r)}}o(pe,"readDynamic");function we(t,e,r){if(e==null)t.writeLength(110);else if(e===!0)t.writeLength(116);else if(e===!1)t.writeLength(102);else if(typeof e=="number"&&(e|0)===e)t.writeLength(105),t.writeInt(e);else if(typeof e=="number")t.writeLength(100),t.writeDouble(e);else if(typeof e=="bigint")t.writeLength(108),t.writeLong(e);else if(e instanceof Uint8Array)t.writeLength(98),t.writeLength(e.length),t.writeBuffer(e);else if(e instanceof Date)t.writeLength(68),t.writeLong(+e);else if(e instanceof RegExp){t.writeLength(82),t.writeString(e.source);const n=e.flags;t.writeByte((n.includes("i")?1:0)||(n.includes("m")?2:0))}else if(e instanceof Error)t.writeLength(69),t.writeError(e);else if(typeof e=="object"&&T in e)t.writeLength(79),t.writeString(e[T]);else if(typeof e=="function"){r.push(e),t.writeLength(70);let n;e instanceof _?n=e:(n=oe(e),Be.set(e,()=>ae(n))),t.writeString(n.type),t.writeString(n.method)}else if(r.includes(e))t.writeLength(-(r.indexOf(e)*4));else if(typeof e=="string"){const n=new TextEncoder().encode(e);t.writeLength(-(n.length*4+1)),t.writeBytes(n)}else if(Array.isArray(e)){r.push(e),t.writeLength(-(e.length*4+3));for(let n of e)we(t,n,r)}else{for(let[n,i,s]of Ie){if(!i(e))continue;const c=new TextEncoder().encode(n);t.writeLength(c.length+128),t.writeBytes(c),s(t,e,r);return}if(typeof e=="object"){r.push(e);const n=Object.entries(e);t.writeLength(-(n.length*4+2));for(let[i,s]of n)t.writeString(i),we(t,s,r)}else throw new Error("Unknown type for "+e)}}o(we,"writeDynamic");const Be=new WeakMap;function ne(t){for(let e of t)Be.get(e)?.()}o(ne,"freeDynamic");class x{static{o(this,"DataOutput")}_buf;_data;_count=0;constructor(e=32){this._buf=typeof e=="number"?new Uint8Array(e):e,this._data=new DataView(this._buf.buffer)}ensureCapacity(e){if(e+=this._count,e>this._buf.byteLength){let r=new Uint8Array(Math.max(this._buf.byteLength*2,e));this._data=new DataView(r.buffer),r.set(this._buf),this._buf=r}}writeByte(e){this.ensureCapacity(1),this._buf[this._count]=e,this._count++}writeBytes(e){this.ensureCapacity(e.length),this._buf.set(e,this._count),this._count+=e.length}writeBuffer(e){this.writeBytes(e)}writeBoolean(e){this.writeByte(e?1:0)}writeNullBoolean(e){this.writeByte(e==null?2:e?1:0)}writeShort(e){this.ensureCapacity(2),this._data.setInt16(this._count,e),this._count+=2}writeChar(e){this.writeShort(e.charCodeAt(0))}writeInt(e){this.ensureCapacity(4),this._data.setInt32(this._count,e),this._count+=4}writeLong(e){typeof e=="number"?(this.writeInt(e/2**32),this.writeInt(e%2**32)):(this.writeInt(Number(e/BigInt(2**32))),this.writeInt(Number(e%BigInt(2**32))))}writeFloat(e){this.ensureCapacity(4),this._data.setFloat32(this._count,e),this._count+=4}writeDouble(e){this.ensureCapacity(8),this._data.setFloat64(this._count,e),this._count+=8}writeString(e){if(e==null){this.writeLength(-1);return}let r=new TextEncoder().encode(e);this.writeLength(r.length),this.writeBytes(r)}writeLength(e){let r=(e<0?~e:e)>>>0;for(;r>=128;)this.writeByte(r|128),r>>=7;e<0?(this.writeByte(r|128),this.writeByte(0)):this.writeByte(r)}writeByteArray(e){e?(this.writeLength(e.length),this.writeBytes(e)):this.writeLength(-1)}writeArray(e,r){if(!e)this.writeLength(-1);else{this.writeLength(e.length);for(let n=0;n<e.length;n++)r.call(this,e[n])}}toBuffer(e=0){return this._buf.slice(e,this._count-e)}writeError(e){try{throw m.wrapAndFreeze(e)}catch(r){r.write(this)}}writeDynamic(e,r=[]){we(this,e,r)}}const O=new Map,B=new Map;function wt(t){for(let e of O.values())v.get(e)?.(t);O.clear();for(let e of B.values())e.cancelSelf()}o(wt,"disposeConnection");function U(t){if(G==null)throw exports.RpcConnectionError.new("Not connected");G.send(t.toBuffer())}o(U,"sendRaw");function yt(t,e,r){O.set(t,e);try{U(r)}catch(n){v.get(e)?.(n)}}o(yt,"sendCall");var E=(t=>(t[t.FunctionCall=0]="FunctionCall",t[t.FunctionSuccess=1]="FunctionSuccess",t[t.FunctionError=2]="FunctionError",t[t.FunctionCancel=3]="FunctionCancel",t[t.MessageToExecutor=4]="MessageToExecutor",t[t.MessageToCaller=5]="MessageToCaller",t))(E||{});async function bt(t){const e=t.readByte();switch(e){case 0:{const r=t.readLength(),n=[];let i=!1,s=null,c=null;const l=new Promise((a,b)=>{s=o(u=>{a(u),i=!0;const h=new x;h.writeByte(1),h.writeLength(r),h.writeDynamic(u),U(h),B.delete(r),ne(n)},"resolve"),c=o(u=>{b(u),i=!0;const h=new x;h.writeByte(2),h.writeLength(r),h.writeError(u),U(h),B.delete(r),ne(n)},"reject")});l.catch(()=>{});try{const a=t.readString();if(a==null)throw exports.RpcTypeNotFoundError.new(null);const b=S.get(a);if(!b)throw exports.RpcTypeNotFoundError.new(a);const u=t.readString(),h=t.readArray(()=>t.readDynamic(n))??[],g=new AbortController,d={type:a,method:u,get finished(){return i},promise:l,sendMessage(...w){if(i)return d;const f=new x;f.writeByte(5),f.writeLength(r);const p=[];return f.writeArray(w,N=>f.writeDynamic(N,p)),n.push(...p),U(f),d},addMessageListener(w){return ee(d,w),d},cancelToken:g.signal,cancelSelf:()=>g.abort(),[Symbol.asyncIterator]:()=>Z(d)};B.set(r,d),await ke(Pe.bind(null,b,a,u,...h),d,s,c,a,u,h)}catch(a){a instanceof m||(a=exports.RpcDataError.new(`Error reading binary stream (${E[e]})`,a)),c(a)}break}case 1:{const r=t.readLength(),n=O.get(r);if(n==null){console.warn(`[Rpc] No activeRequest[${r}] (${E[e]})`);break}try{A.get(n)?.(t.readDynamic())}catch(i){v.get(n)?.(exports.RpcDataError.new(`Error reading binary stream (${E[e]})`,i))}finally{O.delete(r)}break}case 2:{const r=t.readLength(),n=O.get(r);if(n==null){console.warn(`[Rpc] No activeRequest[${r}] (${E[e]})`);break}try{let i;try{i=t.readError()}catch(s){i=exports.RpcDataError.new(`Error reading binary stream (${E[e]})`,s)}throw i}catch(i){v.get(n)?.(i)}finally{O.delete(r)}break}case 3:{const r=t.readLength();let n=B.get(r);if(!n){console.warn(`[Rpc] No currentlyExecuting[${r}] (${E[e]})`);break}n.cancelSelf();break}case 4:{const r=t.readLength();let n=B.get(r);if(!n){console.warn(`[Rpc] No currentlyExecuting[${r}] (${E[e]})`);break}const i=[],s=t.readArray(()=>t.readDynamic(i))??[];K(n,s);break}case 5:{const r=t.readLength();let n=O.get(r);if(!n){console.warn(`[Rpc] No activeRequest[${r}] (${E[e]})`);break}const i=[],s=t.readArray(()=>t.readDynamic(i))??[];K(n,s);break}}}o(bt,"receiveRpc");class Re{static{o(this,"DataInput")}_buf;_data;_pos;_count;constructor(e,r=0,n=e.length){this._buf=e,this._data=new DataView(e.buffer),this._pos=r,this._count=r+n}readFully(e,r=0,n=e.length){let i=this._pos;if(this._count-i<n)throw new RangeError("not enough bytes available to use readFully");for(let c=r;c<r+n;c++)e[c]=this._buf[i++];this._pos=i}skip(e){let r=this.available();return e<r&&(r=e<0?0:e),this._pos+=r,r}available(){return this._count-this._pos}readAll(){return this._buf.slice(this._pos,this._pos=this._count)}readBuffer(e){if(e>this.available())throw new RangeError;return this._buf.slice(this._pos,this._pos+=e)}readByte(){return this._data.getUint8(this._pos++)}readBoolean(){return this.readByte()!=0}readNullBoolean(){const e=this.readByte();return e<2?e==1:null}readShort(){const e=this._data.getInt16(this._pos);return this._pos+=2,e}readUShort(){const e=this._data.getUint16(this._pos);return this._pos+=2,e}readChar(){return String.fromCharCode(this.readUShort())}readInt(){const e=this._data.getInt32(this._pos);return this._pos+=4,e}readLong(){return BigInt(this.readInt())*BigInt(2**32)+BigInt(this.readInt()>>>0)}readFloat(){const e=this._data.getFloat32(this._pos);return this._pos+=4,e}readDouble(){const e=this._data.getFloat64(this._pos);return this._pos+=8,e}readString(){let e=this.readLength();return e==-1?null:new TextDecoder().decode(this.readBuffer(e))}readLength(){let e=0,r=0;for(;;){const n=this.readByte();if(n==0)return r==0?0:~e;if(!(n&128))return e|=n<<r,e;e|=(n&127)<<r,r+=7}}readArray(e){const r=this.readLength();if(r==-1)return null;const n=[];for(let i=0;i<r;i++)n[i]=e.call(this);return n}readError(){return m.read(this)}readDynamic(e=[]){return pe(this,e)}}let j=!1,Ee,ye,ie=new Promise((t,e)=>[Ee,ye]=[t,e]);ie.catch(()=>{});async function mt(){for(;;)if(await ie.then(()=>!0,()=>!1))return}o(mt,"waitConnected");let D;if(xe){const t="RPC_URL"in globalThis?globalThis.RPC_URL:process.env.RPC_URL,e="RPC_TOKEN"in globalThis?globalThis.RPC_TOKEN:process.env.RPC_TOKEN;t?D=o(async r=>{const n=new URL(t);n.search=r.toString();const i="require"in globalThis?globalThis.require("ws"):(await import("ws")).WebSocket;return new i(n,e==null?{}:{headers:{Cookie:"RPC_TOKEN="+e}})},"createWebSocket"):(console.warn("[Rpc] RPC_URL is not defined => RPC will not connect"),D=o(async()=>({}),"createWebSocket"))}else if("document"in globalThis)D=o(async t=>new WebSocket("ws"+document.location.origin.substring(4)+"/rpc?"+t),"createWebSocket");else{const t="RPC_URL"in globalThis?globalThis.RPC_URL:process.env.RPC_URL,e="RPC_TOKEN"in globalThis?globalThis.RPC_TOKEN:process.env.RPC_TOKEN;t?D=o(async r=>{const n=new URL(t);return n.search=r.toString(),new WebSocket(n,e==null?{}:{headers:{Cookie:"RPC_TOKEN="+e}})},"createWebSocket"):(console.warn("[Rpc] RPC_URL is not defined => RPC will not connect"),D=o(async()=>({}),"createWebSocket"))}function Ne(t){const e=ye;ie=new Promise((r,n)=>[Ee,ye]=[r,n]),ie.catch(()=>{}),e(t),wt(t)}o(Ne,"closeRpc");let G=null;async function Rt(t){let e=$,r=new Set;const n=new URLSearchParams;n.set("id",R),r.add("$"+R),e!=null&&n.set("name",e);for(let s of S.keys())r.has(s)||(r.add(s),n.append("type",s));const i=await D(n);i.onclose=()=>{setTimeout(t,1e3),G&&(G=null,j=!1,console.info("[Rpc] Reconnecting to RPC"),Ne(exports.RpcConnectionError.new("Connection closed by "+C.prettyName)))},i.onopen=async()=>{console.info("[Rpc] Connected to RPC");try{G=i;const s=new Set(S.keys()),c=new Set(r);for(let l of s)c.delete(l)&&s.delete(l);s.size||c.size?$!=e?await y(null,"H",$,[...s.keys()],[...c.keys()]):await y(null,"H",[...s.keys()],[...c.keys()]):$!=e&&await y(null,"H",$),j=!0,Ee()}catch(s){console.error("[Rpc] Error connecting to RPC: ",s),Ne(s),i?.close(4e3,"Error registering types");return}},i.binaryType="arraybuffer",i.onmessage=s=>{const c=s.data;typeof c=="string"?console.log("[Rpc] WebSocket Message:",c):bt(new Re(new Uint8Array(c))).catch(l=>console.warn("[Rpc] Error receiving Packet:",l))}}o(Rt,"connectOnce");o(async function(){for(await Promise.resolve();;)await new Promise(e=>Rt(e))},"connectLoop")();let $=null;async function Et(t){$=t;try{j&&await y(null,"N",t)}catch(e){console.error(`[Rpc] Error changing name to "${t}":`,e)}}o(Et,"setName");function De(t){return function(e){Ie.push([t,r=>r instanceof e,(r,n,i)=>n.write(r,i)]),je.set(t,(r,n)=>e.read(r,n))}}o(De,"CustomDynamicType");function Ue(t){return e=>void $e(t??e.prototype.constructor.name,e)}o(Ue,"RpcProvider");Promise.resolve().then(()=>vt).then(t=>Object.assign(globalThis,t));class C{static id=R;static get prettyName(){return C.name!=null?`${C.name} (${C.id})`:C.id}static get name(){return $}static setName=Et;static get isConnected(){return j}static get waitUntilConnected(){return mt()}static createObject=I;static createFunction=(e,r)=>new _(e,r);static registerFunction=oe;static unregisterFunction=ae;static callLocal=dt;static callFunction=y;static getContext=ht;static runWithContext=ft;static registerType=$e;static unregisterType=ct;static generateTypeName=at;static getObjectWithFallback=async(e,...r)=>await y("Rpc","getObjectWithFallback",e,...r);static checkTypes=async(...e)=>await y("Rpc","checkTypes",...e);static checkType=async e=>await y("Rpc","checkType",e);static getAllTypes=async()=>await y("Rpc","getAllTypes");static getAllConnections=async()=>await y("Rpc","getAllConnections");static getRegistrations=async(e=!1)=>await y("Rpc","getRegistrations",e);static evalObject=async e=>await y("Rpc","evalObject",e);static evalString=async e=>await y("Rpc","evalString",e);static listenCalls=()=>y("Rpc","listenCalls");static root=me;static getObjectMethods=e=>(typeof e=="string"?I(e):e)[W]();static getObjectExists=e=>(typeof e=="string"?I(e):e)[X]();static getObjectType=e=>e[T];static getMethodSignatures=(e,r,n=!1)=>new _(e,r).getMethodSignatures(n)}const vt=Object.freeze(Object.defineProperty({__proto__:null,CustomDynamicType:De,DataInput:Re,DataOutput:x,PendingCall:se,RPC_ROOT:me,Rpc:C,RpcCallError:q,get RpcConnectionError(){return exports.RpcConnectionError},RpcCustomError:L,get RpcDataError(){return exports.RpcDataError},RpcError:m,get RpcEvalError(){return exports.RpcEvalError},RpcFunction:_,get RpcMetaMethodNotFoundError(){return exports.RpcMetaMethodNotFoundError},get RpcMethodNotFoundError(){return exports.RpcMethodNotFoundError},RpcObjectExists:X,RpcObjectGetMethodSignatures:J,RpcObjectGetMethods:W,RpcObjectGetRpcVersion:Q,RpcObjectType:T,RpcProvider:Ue,get RpcTypeNotFoundError(){return exports.RpcTypeNotFoundError},createRemoteObject:I,getAsyncIterator:Z,listenersMap:k,pendingMap:P,registerFunction:oe,registerReceive:ee,rejectCall:v,resolveCall:A,runReceiveMessage:K,unregisterFunction:ae},Symbol.toStringTag,{value:"Module"}));exports.CustomDynamicType=De;exports.DataInput=Re;exports.DataOutput=x;exports.PendingCall=se;exports.RPC_ROOT=me;exports.Rpc=C;exports.RpcCallError=q;exports.RpcCustomError=L;exports.RpcError=m;exports.RpcFunction=_;exports.RpcObjectExists=X;exports.RpcObjectGetMethodSignatures=J;exports.RpcObjectGetMethods=W;exports.RpcObjectGetRpcVersion=Q;exports.RpcObjectType=T;exports.RpcProvider=Ue;exports.createRemoteObject=I;exports.getAsyncIterator=Z;exports.listenersMap=k;exports.pendingMap=P;exports.registerFunction=oe;exports.registerReceive=ee;exports.rejectCall=v;exports.resolveCall=A;exports.runReceiveMessage=K;exports.unregisterFunction=ae;
//# sourceMappingURL=rpc.cjs.map
