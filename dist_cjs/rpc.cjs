"use strict";var qe=Object.create;var oe=Object.defineProperty;var Ge=Object.getOwnPropertyDescriptor;var ze=Object.getOwnPropertyNames;var Ve=Object.getPrototypeOf,He=Object.prototype.hasOwnProperty;var o=(t,e)=>oe(t,"name",{value:e,configurable:!0});var Je=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of ze(e))!He.call(t,i)&&i!==r&&oe(t,i,{get:()=>e[i],enumerable:!(n=Ge(e,i))||n.enumerable});return t};var Xe=(t,e,r)=>(r=t!=null?qe(Ve(t)):{},Je(e||!t||!t.__esModule?oe(r,"default",{value:t,enumerable:!0}):r,t));Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const ce=[new Map,new Map];function L(t){return function(e){const[r,n]=ce;r.set(t,e),n.set(e,t)}}o(L,"RpcCustomError");var _e=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Qe(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}o(Qe,"getDefaultExportFromCjs");var Ne={exports:{}},ae={exports:{}},Re;function Ye(){return Re||(Re=1,function(t,e){(function(r,n){t.exports=n()})(_e,function(){function r(f){return!isNaN(parseFloat(f))&&isFinite(f)}o(r,"_isNumber");function n(f){return f.charAt(0).toUpperCase()+f.substring(1)}o(n,"_capitalize");function i(f){return function(){return this[f]}}o(i,"_getter");var s=["isConstructor","isEval","isNative","isToplevel"],c=["columnNumber","lineNumber"],l=["fileName","functionName","source"],a=["args"],y=["evalOrigin"],u=s.concat(c,l,a,y);function h(f){if(f)for(var d=0;d<u.length;d++)f[u[d]]!==void 0&&this["set"+n(u[d])](f[u[d]])}o(h,"StackFrame"),h.prototype={getArgs:function(){return this.args},setArgs:function(f){if(Object.prototype.toString.call(f)!=="[object Array]")throw new TypeError("Args must be an Array");this.args=f},getEvalOrigin:function(){return this.evalOrigin},setEvalOrigin:function(f){if(f instanceof h)this.evalOrigin=f;else if(f instanceof Object)this.evalOrigin=new h(f);else throw new TypeError("Eval Origin must be an Object or StackFrame")},toString:function(){var f=this.getFileName()||"",d=this.getLineNumber()||"",N=this.getColumnNumber()||"",V=this.getFunctionName()||"";return this.getIsEval()?f?"[eval] ("+f+":"+d+":"+N+")":"[eval]:"+d+":"+N:V?V+" ("+f+":"+d+":"+N+")":f+":"+d+":"+N}},h.fromString=o(function(d){var N=d.indexOf("("),V=d.lastIndexOf(")"),De=d.substring(0,N),je=d.substring(N+1,V).split(","),be=d.substring(V+1);if(be.indexOf("@")===0)var se=/@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(be,""),Ue=se[1],Ke=se[2],We=se[3];return new h({functionName:De,args:je||void 0,fileName:Ue,lineNumber:Ke||void 0,columnNumber:We||void 0})},"StackFrame$$fromString");for(var g=0;g<s.length;g++)h.prototype["get"+n(s[g])]=i(s[g]),h.prototype["set"+n(s[g])]=function(f){return function(d){this[f]=!!d}}(s[g]);for(var p=0;p<c.length;p++)h.prototype["get"+n(c[p])]=i(c[p]),h.prototype["set"+n(c[p])]=function(f){return function(d){if(!r(d))throw new TypeError(f+" must be a Number");this[f]=Number(d)}}(c[p]);for(var w=0;w<l.length;w++)h.prototype["get"+n(l[w])]=i(l[w]),h.prototype["set"+n(l[w])]=function(f){return function(d){this[f]=String(d)}}(l[w]);return h})}(ae)),ae.exports}o(Ye,"requireStackframe");(function(t,e){(function(r,n){t.exports=n(Ye())})(_e,o(function(n){var i=/(^|@)\S+:\d+/,s=/^\s*at .*(\S+:\d+|\(native\))/m,c=/^(eval@)?(\[native code])?$/;return{parse:o(function(a){if(typeof a.stacktrace<"u"||typeof a["opera#sourceloc"]<"u")return this.parseOpera(a);if(a.stack&&a.stack.match(s))return this.parseV8OrIE(a);if(a.stack)return this.parseFFOrSafari(a);throw new Error("Cannot parse given Error object")},"ErrorStackParser$$parse"),extractLocation:o(function(a){if(a.indexOf(":")===-1)return[a];var y=/(.+?)(?::(\d+))?(?::(\d+))?$/,u=y.exec(a.replace(/[()]/g,""));return[u[1],u[2]||void 0,u[3]||void 0]},"ErrorStackParser$$extractLocation"),parseV8OrIE:o(function(a){var y=a.stack.split(`
`).filter(function(u){return!!u.match(s)},this);return y.map(function(u){u.indexOf("(eval ")>-1&&(u=u.replace(/eval code/g,"eval").replace(/(\(eval at [^()]*)|(,.*$)/g,""));var h=u.replace(/^\s+/,"").replace(/\(eval code/g,"(").replace(/^.*?\s+/,""),g=h.match(/ (\(.+\)$)/);h=g?h.replace(g[0],""):h;var p=this.extractLocation(g?g[1]:h),w=g&&h||void 0,f=["eval","<anonymous>"].indexOf(p[0])>-1?void 0:p[0];return new n({functionName:w,fileName:f,lineNumber:p[1],columnNumber:p[2],source:u})},this)},"ErrorStackParser$$parseV8OrIE"),parseFFOrSafari:o(function(a){var y=a.stack.split(`
`).filter(function(u){return!u.match(c)},this);return y.map(function(u){if(u.indexOf(" > eval")>-1&&(u=u.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,":$1")),u.indexOf("@")===-1&&u.indexOf(":")===-1)return new n({functionName:u});var h=/((.*".+"[^@]*)?[^@]*)(?:@)/,g=u.match(h),p=g&&g[1]?g[1]:void 0,w=this.extractLocation(u.replace(h,""));return new n({functionName:p,fileName:w[0],lineNumber:w[1],columnNumber:w[2],source:u})},this)},"ErrorStackParser$$parseFFOrSafari"),parseOpera:o(function(a){return!a.stacktrace||a.message.indexOf(`
`)>-1&&a.message.split(`
`).length>a.stacktrace.split(`
`).length?this.parseOpera9(a):a.stack?this.parseOpera11(a):this.parseOpera10(a)},"ErrorStackParser$$parseOpera"),parseOpera9:o(function(a){for(var y=/Line (\d+).*script (?:in )?(\S+)/i,u=a.message.split(`
`),h=[],g=2,p=u.length;g<p;g+=2){var w=y.exec(u[g]);w&&h.push(new n({fileName:w[2],lineNumber:w[1],source:u[g]}))}return h},"ErrorStackParser$$parseOpera9"),parseOpera10:o(function(a){for(var y=/Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,u=a.stacktrace.split(`
`),h=[],g=0,p=u.length;g<p;g+=2){var w=y.exec(u[g]);w&&h.push(new n({functionName:w[3]||void 0,fileName:w[2],lineNumber:w[1],source:u[g]}))}return h},"ErrorStackParser$$parseOpera10"),parseOpera11:o(function(a){var y=a.stack.split(`
`).filter(function(u){return!!u.match(i)&&!u.match(/^Error created at/)},this);return y.map(function(u){var h=u.split("@"),g=this.extractLocation(h.pop()),p=h.shift()||"",w=p.replace(/<anonymous function(: (\w+))?>/,"$2").replace(/\([^)]*\)/g,"")||void 0,f;p.match(/\(([^)]*)\)/)&&(f=p.replace(/^[^(]+\(([^)]*)\)$/,"$1"));var d=f===void 0||f==="[arguments not available]"?void 0:f.split(",");return new n({functionName:w,args:d,fileName:g[0],lineNumber:g[1],columnNumber:g[2],source:u})},this)},"ErrorStackParser$$parseOpera11")}},"ErrorStackParser"))})(Ne);var Ze=Ne.exports;const Y=Qe(Ze);function le(t){return t.replaceAll("\r","").replaceAll(/^\n+|\n+$/g,"").replaceAll(/^  +/gm,"	")}o(le,"fixString");function Z(t){let e="";for(let r of t){if(r.functionName?.includes("$RPC_MARKER_BEGIN$"))break;e+=`
	at `+r}return e}o(Z,"framesToString");function Se(t){return t===void 0?"":t instanceof b?`
caused by: `+t.toString():t instanceof Error?`
caused by: `+le(t.toString())+Z(Y.parse(t))+Se(t.cause):`
caused by: `+le(t?.toString()??"null")}o(Se,"causeToString");function Oe(t,e){return(t===b||Oe(t.__proto__,e))&&e[0].functionName?.replace(/^new /,"")===t.name?(e.shift(),!0):!1}o(Oe,"removeFromStackTrace");class b extends Error{static{o(this,"RpcError")}from;data={};#t=[];get stackTrace(){let e=this.#e;return e+=Z(this.#t),e+=this.#n,e.replaceAll(/^\n+/g,"")}#e="";#r=!1;#n="";constructor(...e){let r=null,n=null,i=null,s={},c;switch(e.length){case 1:[n]=e;break;case 2:[n,c]=e;break;case 4:[n,r,n,i]=e;break;case 5:e[4]instanceof b?[n,r,n,i,c]=e:[n,r,n,i,s]=e;break;case 6:[n,r,n,i,s,c]=e;break;default:throw new Error("Invalid arg count")}c!=null?super(n??void 0,{cause:c}):super(n??void 0),this.name=this.constructor.name,this.from=r??C.prettyName;const l=ce[1].get(this.constructor);if(l!=null&&(this.data.$type=l),Object.assign(this.data,s??{}),i==null)this.#r=!0,this.#t=Y.parse(this),Oe(this.constructor,this.#t);else{this.#e=`
`+le(i);const a=this.#e.indexOf(`
caused by: `);a!=-1&&(this.#n+=this.#e.substring(a),this.#e=this.#e.substring(0,a))}this.#n+=Se(c),this.stack=this.toString()}toString(){let e=this.name+"("+this.from+")";this.message?.trim()&&(e+=": "+this.message);const r=this.stackTrace;return r?.trim()&&(e+=`
`+r),e}write(e){e.writeString(this.name),e.writeString(this.from),e.writeString(this.message),e.writeString(this.stackTrace),e.writeString(Object.keys(this.data).length==0?null:JSON.stringify(this.data))}static read(e){const r=e.readString(),n=e.readString()??"???",i=e.readString(),s=e.readString()??"";let c;try{c=JSON.parse(e.readString()??"null")}catch(l){if(l instanceof RangeError)c={$info:"JsonData was not included, due to an old PlayifyRpc version"};else throw l}return b.create(r,n,i,s,c)}static create(e,r,n,i,s){const c=s?.$type,l=ce[0].get(c)??b;return new l(e,r,n,i,s)}static wrapAndFreeze(e){return e instanceof b?(e.#r&&(e.#r=!1,e.#e+=Z(e.#t),e.#t=[],e.stack=e.toString()),e):new b(e.name,e instanceof b?e.from:null,e.message,Z(Y.parse(e)).substring(1),{},e.cause)}unfreeze(e,r){return this.#r?this:(this.#r=!0,this.#t=Y.parse(e).slice(r),this.stack=this.toString(),this)}trashLocalStack(){return this.#r=!1,this.#t=[],this.stack=this.toString(),this}append(e,r,n){return this.#e+=`
	rpc `+(n==null?"<<callLocal>>":(e??"<<null>>")+"."+(r??"<<null>>")+"("+n.map(i=>JSON.stringify(i)).join(",")+")"),this.stack=this.toString(),this}}const Fe=globalThis?.process?.versions?.node!=null,Ee="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",ue=o(()=>Date.now().toString(36)+Array(10).fill(void 0).map(()=>Ee[Math.floor(Math.random()*Ee.length)]).join(""),"randomId");let R;if(Fe)try{process?.versions.bun?R="bun@"+require("os").hostname()+"@"+process.pid:R="node@"+process.binding("os").getHostname()+"@"+process.pid}catch{R="node-alternative@"+process.platform+":"+process.arch+"@"+process.pid}else"document"in globalThis?R="web@"+document.location+"#"+ue():R="js@"+ue();var Te=Object.defineProperty,et=Object.getOwnPropertyDescriptor,tt=o((t,e,r)=>e in t?Te(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,"__defNormalProp"),G=o((t,e,r,n)=>{for(var i=n>1?void 0:n?et(e,r):e,s=t.length-1,c;s>=0;s--)(c=t[s])&&(i=(n?c(e,r,i):c(i))||i);return n&&i&&Te(e,r,i),i},"__decorateClass"),J=o((t,e,r)=>(tt(t,typeof e!="symbol"?e+"":e,r),r),"__publicField");const H=o(t=>t==null?"null":'"'+t+'"',"quoted");class z extends b{static{o(this,"RpcCallError")}}exports.RpcTypeNotFoundError=class extends z{static{o(this,"RpcTypeNotFoundError")}};J(exports.RpcTypeNotFoundError,"new",t=>new exports.RpcTypeNotFoundError(null,null,`Type ${H(t)} does not exist`,"",{type:t}));exports.RpcTypeNotFoundError=G([L("$type")],exports.RpcTypeNotFoundError);exports.RpcMethodNotFoundError=class extends z{static{o(this,"RpcMethodNotFoundError")}};J(exports.RpcMethodNotFoundError,"new",(t,e)=>new exports.RpcMethodNotFoundError(null,null,`Method ${H(e)} does not exist on type ${H(t)}`,"",{type:t,method:e}));exports.RpcMethodNotFoundError=G([L("$method")],exports.RpcMethodNotFoundError);exports.RpcMetaMethodNotFoundError=class extends exports.RpcMethodNotFoundError{static{o(this,"RpcMetaMethodNotFoundError")}};J(exports.RpcMetaMethodNotFoundError,"new",(t,e)=>new exports.RpcMetaMethodNotFoundError(null,null,`Meta-Method ${H(e)} does not exist on type ${H(t)}`,"",{type:t,method:null,meta:e}));exports.RpcMetaMethodNotFoundError=G([L("$method-meta")],exports.RpcMetaMethodNotFoundError);exports.RpcConnectionError=class extends z{static{o(this,"RpcConnectionError")}};J(exports.RpcConnectionError,"new",t=>new exports.RpcConnectionError(null,null,t,""));exports.RpcConnectionError=G([L("$connection")],exports.RpcConnectionError);exports.RpcEvalError=class extends z{static{o(this,"RpcEvalError")}};exports.RpcEvalError=G([L("$eval")],exports.RpcEvalError);exports.RpcDataError=class extends b{static{o(this,"RpcDataError")}};J(exports.RpcDataError,"new",(t,e)=>new exports.RpcDataError(null,null,t,"",e));exports.RpcDataError=G([L("$data")],exports.RpcDataError);const de=Object.create(null),_=new Map;_.set("$"+R,de);async function rt(){return"$"+R+"$"+ue()}o(rt,"generateTypeName");async function Me(t,e){if(!_.has(t)){_.set(t,e);try{B&&await m(null,"+",t)}catch(r){console.error(`[Rpc] Error registering type "${t}":`,r),_.delete(t)}}}o(Me,"registerType");async function nt(t){if(_.has(t)){try{B&&await m(null,"-",t)}catch(e){console.error(`[Rpc] Error unregistering type "${t}":`,e)}_.delete(t)}}o(nt,"unregisterType");async function ve(t){const e=t[I];return e?await e.call(t):Object.getOwnPropertyNames(t).filter(r=>typeof t[r]=="function")}o(ve,"getMethods");async function Le(t,e,r,...n){if(r!=null){let s=t[r];if(s==null){let l=(await ve(t)).find(a=>a.toLowerCase()==r.toLowerCase());l!=null&&(s=t[l])}const c={}[r];if(s==null||s===c)throw exports.RpcMethodNotFoundError.new(e,r);try{return await{async $RPC_MARKER_BEGIN$(){return await s.call(t,...n)}}.$RPC_MARKER_BEGIN$()}catch(l){throw b.wrapAndFreeze(l)}}const i=n.length==0?null:n[0];switch(i){case"M":return ve(t);default:throw exports.RpcMetaMethodNotFoundError.new(e,i)}}o(Le,"invoke");class re{static{o(this,"PendingCall")}[Symbol.toStringTag]="PendingCall";finished=!1;promise;constructor(e,r){try{throw new Error}catch(n){this.promise=new Promise((i,s)=>{P.set(this,c=>{P.delete(this),v.delete(this),this.finished=!0,i(c),ee(r)}),v.set(this,c=>{P.delete(this),v.delete(this),this.finished=!0,s(c instanceof b?c.unfreeze(n,e):c),ee(r)})})}}catch(e){return this.promise.catch(e)}finally(e){return this.promise.finally(e)}then(e,r){return this.promise.then(e,r)}sendMessage(...e){return this}addMessageListener(e){return Q(this,e)}cancel(){}getCaller(){return Promise.resolve(C.prettyName)}[Symbol.asyncIterator](){return X(this)}}function X(t){let e=[],r=[];return t.promise.catch(()=>{}),t.promise.finally(()=>{for(let n of r)n({done:!0,value:void 0})}),t.addMessageListener((...n)=>{(r.shift()??e.push)({done:!1,value:n})}),{async next(){return t.finished?{done:!0,value:void 0}:e.shift()??await new Promise(n=>r.push(n))}}}o(X,"getAsyncIterator");const P=new WeakMap,v=new WeakMap,$=new WeakMap,A=new WeakMap;function Q(t,e){if(A.has(t))A.get(t).push(e);else{A.set(t,[e]);const r=$.get(t)??[];for(let n of r)try{e(...n)}catch(i){console.warn("[Rpc] Error while handling pending message:",i)}}return t}o(Q,"registerReceive");function W(t,e){if(!t.finished)if(A.has(t))for(let r of A.get(t))try{r(...e)}catch(n){console.warn("[Rpc] Error while receiving message:",n)}else $.has(t)?$.set(t,[...$.get(t),e]):$.set(t,[e])}o(W,"runReceiveMessage");let T=null;function it(t,e){const r=T;T=e;try{return t()}finally{T=r}}o(it,"runWithContext");function st(){if(T==null)throw new Error("FunctionCallContext not available");return T}o(st,"getFunctionContext");let ot=0;function m(t,e,...r){if(t!=null){const l=_.get(t);if(l)return xe(Le.bind(null,l,t,e,...r),t,e,r,3)}const n=[],i=new re(2,n),s=new M,c=ot++;try{s.writeByte(E.FunctionCall),s.writeLength(c),s.writeString(t),s.writeString(e),s.writeArray(r,l=>s.writeDynamic(l,n))}catch(l){return v.get(i)?.(l),i}return B||t==null&&K!=null?(i.sendMessage=(...l)=>{if(i.finished)return i;const a=new M;a.writeByte(E.MessageToExecutor),a.writeLength(c);const y=[];return a.writeArray(l,u=>a.writeDynamic(u,y)),n.push(...y),U(a),i},i.cancel=()=>{if(i.finished)return;const l=new M;l.writeByte(E.FunctionCancel),l.writeLength(c),U(l)},i.getCaller=()=>m(null,"c",c),ut(c,i,s),i):(v.get(i)?.(exports.RpcConnectionError.new("Not connected")),i)}o(m,"callRemoteFunction");function at(t){return xe(t,null,null,null,3)}o(at,"callLocal");function xe(t,e,r,n,i){const s=new re(i,[]),c=new AbortController,l={type:e,method:r,sendMessage:(...a)=>(s.finished||W(s,a),l),get finished(){return s.finished},promise:s,addMessageListener:a=>Q(l,a),cancelToken:c.signal,cancelSelf:()=>c.abort(),[Symbol.asyncIterator]:()=>X(l)};return s.sendMessage=(...a)=>(s.finished||W(l,a),s),s.cancel=()=>s.finished||l.cancelSelf(),$e(t,l,P.get(s),v.get(s),e,r,n),s}o(xe,"callLocalFunction");async function $e(t,e,r,n,i,s,c){try{let l;const a=T;T=e;try{l=await{async $RPC_MARKER_BEGIN$(){return await t()}}.$RPC_MARKER_BEGIN$()}finally{T=a}r?.(await l)}catch(l){n?.(b.wrapAndFreeze(l).append(i,s,c))}}o($e,"invokeForPromise");const S=class extends o(function(r){return Object.setPrototypeOf(r,new.target.prototype)},"Extendable"){static{o(this,"RpcFunction2")}constructor(e,r){super(m.bind(null,e,r)),this.type=e,this.method=r}toString(){return`rpc (...params) => ${this.type??"null"}.${this.method}(...params)`}};let ct=Date.now();const fe=new WeakMap;function ne(t){if(t instanceof S)return t;const e=fe.get(t);if(e!=null)return new S("$"+R,e);const r=(ct++).toString(16);de[r]=t,fe.set(t,r);const n="$"+R;return new S(n,r)}o(ne,"registerFunction");function ie(t){const e="$"+R;if(t.type!=e)throw new Error("Can't unregister RemoteFunction, that was not registered locally");delete de[t.method],fe.delete(t)}o(ie,"unregisterFunction");const O=Symbol("RpcObjectType"),q=Symbol("RpcObjectExists"),I=Symbol("RpcObjectGetMethods");function k(t,e=new class{static{o(this,"RpcObject")}[O]=t}){const r=new Map;return new Proxy(e,{get(n,i){if(i==O)return t;if(i==q)return()=>m(null,"E",t);if(i==I)return()=>m(t,null,"M");if(typeof i!="string"||i=="then")return e[i];if(r.has(i))return r.get(i);const s=new S(t,i);return r.set(i,s),s},construct(n,i){return new n(...i)},has(n,i){return i==O||i==I||i==q||i in e}})}o(k,"createRemoteObject");const we=new Proxy({},{get:(t,e)=>typeof e=="string"?k(e):void 0,has:(t,e)=>typeof e=="string"&&e!="then"}),Pe=[],Ae=new Map;function he(t,e){let r=t.readLength();if(r<0){switch(r=-r,r%4){case 0:return e[r/4];case 1:return new TextDecoder().decode(t.readBuffer((r-1)/4));case 2:{const n={};e.push(n);for(let i=0;i<(r-2)/4;i++){const s=t.readString();n[s]=he(t,e)}return n}case 3:{const n=new Array((r-3)/4);e.push(n);for(let i=0;i<n.length;i++)n[i]=he(t,e);return n}}throw new Error("Unreachable code reached")}else if(r>=128){const n=new TextDecoder().decode(t.readBuffer(r-128)),i=Ae.get(n);if(i)return i(t,e);throw new Error("Unknown data type: "+n)}else switch(String.fromCodePoint(r)){case"n":return null;case"t":return!0;case"f":return!1;case"i":return t.readInt();case"d":return t.readDouble();case"l":return t.readLong();case"b":return t.readBuffer(t.readLength());case"D":return new Date(Number(t.readLong()));case"R":{const l=t.readString(),a=t.readByte();return new RegExp(l,"g"+(a&1?"i":"")+(a&2?"m":""))}case"E":return t.readError();case"O":const n=t.readString();if(n==null)throw new Error("Type can't be null");return k(n);case"F":const i=t.readString();if(i==null)throw new Error("Type can't be null");const s=t.readString();if(s==null)throw new Error("Method can't be null");const c=new S(i,s);return e.push(c),c;default:throw new Error("Unknown data type number: "+r)}}o(he,"readDynamic");function ge(t,e,r){if(e==null)t.writeLength(110);else if(e===!0)t.writeLength(116);else if(e===!1)t.writeLength(102);else if(typeof e=="number"&&(e|0)===e)t.writeLength(105),t.writeInt(e);else if(typeof e=="number")t.writeLength(100),t.writeDouble(e);else if(typeof e=="bigint")t.writeLength(108),t.writeLong(e);else if(e instanceof Uint8Array)t.writeLength(98),t.writeLength(e.length),t.writeBuffer(e);else if(e instanceof Date)t.writeLength(68),t.writeLong(+e);else if(e instanceof RegExp){t.writeLength(82),t.writeString(e.source);const n=e.flags;t.writeByte((n.includes("i")?1:0)||(n.includes("m")?2:0))}else if(e instanceof Error)t.writeLength(69),t.writeError(e);else if(typeof e=="object"&&O in e)t.writeLength(79),t.writeString(e[O]);else if(typeof e=="function"){r.push(e),t.writeLength(70);let n;e instanceof S?n=e:(n=ne(e),ke.set(e,()=>ie(n))),t.writeString(n.type),t.writeString(n.method)}else if(r.includes(e))t.writeLength(-(r.indexOf(e)*4));else if(typeof e=="string"){const n=new TextEncoder().encode(e);t.writeLength(-(n.length*4+1)),t.writeBytes(n)}else if(Array.isArray(e)){r.push(e),t.writeLength(-(e.length*4+3));for(let n of e)ge(t,n,r)}else{for(let[n,i,s]of Pe){if(!i(e))continue;const c=new TextEncoder().encode(n);t.writeLength(c.length+128),t.writeBytes(c),s(t,e,r);return}if(typeof e=="object"){r.push(e);const n=Object.entries(e);t.writeLength(-(n.length*4+2));for(let[i,s]of n)t.writeString(i),ge(t,s,r)}else throw new Error("Unknown type for "+e)}}o(ge,"writeDynamic");const ke=new WeakMap;function ee(t){for(let e of t)ke.get(e)?.()}o(ee,"freeDynamic");class M{static{o(this,"DataOutput")}_buf;_data;_count=0;constructor(e=32){this._buf=typeof e=="number"?new Uint8Array(e):e,this._data=new DataView(this._buf.buffer)}ensureCapacity(e){if(e+=this._count,e>this._buf.byteLength){let r=new Uint8Array(Math.max(this._buf.byteLength*2,e));this._data=new DataView(r.buffer),r.set(this._buf),this._buf=r}}writeByte(e){this.ensureCapacity(1),this._buf[this._count]=e,this._count++}writeBytes(e){this.ensureCapacity(e.length),this._buf.set(e,this._count),this._count+=e.length}writeBuffer(e){this.writeBytes(e)}writeBoolean(e){this.writeByte(e?1:0)}writeNullBoolean(e){this.writeByte(e==null?2:e?1:0)}writeShort(e){this.ensureCapacity(2),this._data.setInt16(this._count,e),this._count+=2}writeChar(e){this.writeShort(e.charCodeAt(0))}writeInt(e){this.ensureCapacity(4),this._data.setInt32(this._count,e),this._count+=4}writeLong(e){typeof e=="number"?(this.writeInt(e/2**32),this.writeInt(e%2**32)):(this.writeInt(Number(e/BigInt(2**32))),this.writeInt(Number(e%BigInt(2**32))))}writeFloat(e){this.ensureCapacity(4),this._data.setFloat32(this._count,e),this._count+=4}writeDouble(e){this.ensureCapacity(8),this._data.setFloat64(this._count,e),this._count+=8}writeString(e){if(e==null){this.writeLength(-1);return}let r=new TextEncoder().encode(e);this.writeLength(r.length),this.writeBytes(r)}writeLength(e){let r=(e<0?~e:e)>>>0;for(;r>=128;)this.writeByte(r|128),r>>=7;e<0?(this.writeByte(r|128),this.writeByte(0)):this.writeByte(r)}writeByteArray(e){e?(this.writeLength(e.length),this.writeBytes(e)):this.writeLength(-1)}writeArray(e,r){if(!e)this.writeLength(-1);else{this.writeLength(e.length);for(let n=0;n<e.length;n++)r.call(this,e[n])}}toBuffer(e=0){return this._buf.slice(e,this._count-e)}writeError(e){try{throw b.wrapAndFreeze(e)}catch(r){r.write(this)}}writeDynamic(e,r=[]){ge(this,e,r)}}const F=new Map,D=new Map;function lt(t){for(let e of F.values())v.get(e)?.(t);F.clear();for(let e of D.values())e.cancelSelf()}o(lt,"disposeConnection");function U(t){if(K==null)throw exports.RpcConnectionError.new("Not connected");K.send(t.toBuffer())}o(U,"sendRaw");function ut(t,e,r){F.set(t,e);try{U(r)}catch(n){v.get(e)?.(n)}}o(ut,"sendCall");var E=(t=>(t[t.FunctionCall=0]="FunctionCall",t[t.FunctionSuccess=1]="FunctionSuccess",t[t.FunctionError=2]="FunctionError",t[t.FunctionCancel=3]="FunctionCancel",t[t.MessageToExecutor=4]="MessageToExecutor",t[t.MessageToCaller=5]="MessageToCaller",t))(E||{});async function ft(t){const e=t.readByte();switch(e){case 0:{const r=t.readLength(),n=[];let i=!1,s=null,c=null;const l=new Promise((a,y)=>{s=o(u=>{a(u),i=!0;const h=new M;h.writeByte(1),h.writeLength(r),h.writeDynamic(u),U(h),D.delete(r),ee(n)},"resolve"),c=o(u=>{y(u),i=!0;const h=new M;h.writeByte(2),h.writeLength(r),h.writeError(u),U(h),D.delete(r),ee(n)},"reject")});l.catch(()=>{});try{const a=t.readString();if(a==null)throw exports.RpcTypeNotFoundError.new(null);const y=_.get(a);if(!y)throw exports.RpcTypeNotFoundError.new(a);const u=t.readString(),h=t.readArray(()=>t.readDynamic(n))??[],g=new AbortController,p={type:a,method:u,get finished(){return i},promise:l,sendMessage(...w){if(i)return p;const f=new M;f.writeByte(5),f.writeLength(r);const d=[];return f.writeArray(w,N=>f.writeDynamic(N,d)),n.push(...d),U(f),p},addMessageListener(w){return Q(p,w),p},cancelToken:g.signal,cancelSelf:()=>g.abort(),[Symbol.asyncIterator]:()=>X(p)};D.set(r,p),await $e(Le.bind(null,y,a,u,...h),p,s,c,a,u,h)}catch(a){a instanceof b||(a=exports.RpcDataError.new(`Error reading binary stream (${E[e]})`,a)),c(a)}break}case 1:{const r=t.readLength(),n=F.get(r);if(n==null){console.warn(`[Rpc] No activeRequest[${r}] (${E[e]})`);break}try{P.get(n)?.(t.readDynamic())}catch(i){v.get(n)?.(exports.RpcDataError.new(`Error reading binary stream (${E[e]})`,i))}finally{F.delete(r)}break}case 2:{const r=t.readLength(),n=F.get(r);if(n==null){console.warn(`[Rpc] No activeRequest[${r}] (${E[e]})`);break}try{let i;try{i=t.readError()}catch(s){i=exports.RpcDataError.new(`Error reading binary stream (${E[e]})`,s)}throw i}catch(i){v.get(n)?.(i)}finally{F.delete(r)}break}case 3:{const r=t.readLength();let n=D.get(r);if(!n){console.warn(`[Rpc] No currentlyExecuting[${r}] (${E[e]})`);break}n.cancelSelf();break}case 4:{const r=t.readLength();let n=D.get(r);if(!n){console.warn(`[Rpc] No currentlyExecuting[${r}] (${E[e]})`);break}const i=[],s=t.readArray(()=>t.readDynamic(i))??[];W(n,s);break}case 5:{const r=t.readLength();let n=F.get(r);if(!n){console.warn(`[Rpc] No activeRequest[${r}] (${E[e]})`);break}const i=[],s=t.readArray(()=>t.readDynamic(i))??[];W(n,s);break}}}o(ft,"receiveRpc");class ye{static{o(this,"DataInput")}_buf;_data;_pos;_count;constructor(e,r=0,n=e.length){this._buf=e,this._data=new DataView(e.buffer),this._pos=r,this._count=r+n}readFully(e,r=0,n=e.length){let i=this._pos;if(this._count-i<n)throw new RangeError("not enough bytes available to use readFully");for(let c=r;c<r+n;c++)e[c]=this._buf[i++];this._pos=i}skip(e){let r=this.available();return e<r&&(r=e<0?0:e),this._pos+=r,r}available(){return this._count-this._pos}readAll(){return this._buf.slice(this._pos,this._pos=this._count)}readBuffer(e){if(e>this.available())throw new RangeError;return this._buf.slice(this._pos,this._pos+=e)}readByte(){return this._data.getUint8(this._pos++)}readBoolean(){return this.readByte()!=0}readNullBoolean(){const e=this.readByte();return e<2?e==1:null}readShort(){const e=this._data.getInt16(this._pos);return this._pos+=2,e}readUShort(){const e=this._data.getUint16(this._pos);return this._pos+=2,e}readChar(){return String.fromCharCode(this.readUShort())}readInt(){const e=this._data.getInt32(this._pos);return this._pos+=4,e}readLong(){return BigInt(this.readInt())*BigInt(2**32)+BigInt(this.readInt()>>>0)}readFloat(){const e=this._data.getFloat32(this._pos);return this._pos+=4,e}readDouble(){const e=this._data.getFloat64(this._pos);return this._pos+=8,e}readString(){let e=this.readLength();return e==-1?null:new TextDecoder().decode(this.readBuffer(e))}readLength(){let e=0,r=0;for(;;){const n=this.readByte();if(n==0)return r==0?0:~e;if(!(n&128))return e|=n<<r,e;e|=(n&127)<<r,r+=7}}readArray(e){const r=this.readLength();if(r==-1)return null;const n=[];for(let i=0;i<r;i++)n[i]=e.call(this);return n}readError(){return b.read(this)}readDynamic(e=[]){return he(this,e)}}let B=!1,me,pe,te=new Promise((t,e)=>[me,pe]=[t,e]);te.catch(()=>{});async function ht(){for(;;)if(await te.then(()=>!0,()=>!1))return}o(ht,"waitConnected");let j;if(Fe){const t="RPC_URL"in globalThis?globalThis.RPC_URL:process.env.RPC_URL,e="RPC_TOKEN"in globalThis?globalThis.RPC_TOKEN:process.env.RPC_TOKEN;t?j=o(async r=>{const n=new URL(t);n.search=r.toString();const i="require"in globalThis?globalThis.require("ws"):(await import("ws")).WebSocket;return new i(n,e==null?{}:{headers:{Cookie:"RPC_TOKEN="+e}})},"createWebSocket"):(console.warn("[Rpc] RPC_URL is not defined => RPC will not connect"),j=o(async()=>({}),"createWebSocket"))}else if("document"in globalThis)j=o(async t=>new WebSocket("ws"+document.location.origin.substring(4)+"/rpc?"+t),"createWebSocket");else{const t="RPC_URL"in globalThis?globalThis.RPC_URL:process.env.RPC_URL,e="RPC_TOKEN"in globalThis?globalThis.RPC_TOKEN:process.env.RPC_TOKEN;t?j=o(async r=>{const n=new URL(t);return n.search=r.toString(),new WebSocket(n,e==null?{}:{headers:{Cookie:"RPC_TOKEN="+e}})},"createWebSocket"):(console.warn("[Rpc] RPC_URL is not defined => RPC will not connect"),j=o(async()=>({}),"createWebSocket"))}function Ce(t){const e=pe;te=new Promise((r,n)=>[me,pe]=[r,n]),te.catch(()=>{}),e(t),lt(t)}o(Ce,"closeRpc");let K=null;async function gt(t){let e=x,r=new Set;const n=new URLSearchParams;n.set("id",R),r.add("$"+R),e!=null&&n.set("name",e);for(let s of _.keys())r.has(s)||(r.add(s),n.append("type",s));const i=await j(n);i.onclose=()=>{setTimeout(t,1e3),K&&(K=null,B=!1,console.info("[Rpc] Reconnecting to RPC"),Ce(exports.RpcConnectionError.new("Connection closed by "+C.prettyName)))},i.onopen=async()=>{console.info("[Rpc] Connected to RPC");try{K=i;const s=new Set(_.keys()),c=new Set(r);for(let l of s)c.delete(l)&&s.delete(l);s.size||c.size?x!=e?await m(null,"H",x,[...s.keys()],[...c.keys()]):await m(null,"H",[...s.keys()],[...c.keys()]):x!=e&&await m(null,"H",x),B=!0,me()}catch(s){console.error("[Rpc] Error connecting to RPC: ",s),Ce(s),i?.close(4e3,"Error registering types");return}},i.binaryType="arraybuffer",i.onmessage=s=>{const c=s.data;typeof c=="string"?console.log("[Rpc] WebSocket Message:",c):ft(new ye(new Uint8Array(c))).catch(l=>console.warn("[Rpc] Error receiving Packet:",l))}}o(gt,"connectOnce");o(async function(){for(await Promise.resolve();;)await new Promise(e=>gt(e))},"connectLoop")();let x=null;async function pt(t){x=t;try{B&&await m(null,"N",t)}catch(e){console.error(`[Rpc] Error changing name to "${t}":`,e)}}o(pt,"setName");function Ie(t){return function(e){Pe.push([t,r=>r instanceof e,(r,n,i)=>n.write(r,i)]),Ae.set(t,(r,n)=>e.read(r,n))}}o(Ie,"CustomDynamicType");function Be(t){return e=>void Me(t??e.prototype.constructor.name,e)}o(Be,"RpcProvider");Promise.resolve().then(()=>dt).then(t=>Object.assign(globalThis,t));class C{static id=R;static get prettyName(){return C.name!=null?`${C.name} (${C.id})`:C.id}static get name(){return x}static setName=pt;static get isConnected(){return B}static get waitUntilConnected(){return ht()}static createObject=k;static createFunction=(e,r)=>new S(e,r);static registerFunction=ne;static unregisterFunction=ie;static callLocal=at;static callFunction=m;static getContext=st;static runWithContext=it;static registerType=Me;static unregisterType=nt;static generateTypeName=rt;static getObjectWithFallback=async(e,...r)=>await m("Rpc","getObjectWithFallback",e,...r);static checkTypes=async(...e)=>await m("Rpc","checkTypes",...e);static checkType=async e=>await m("Rpc","checkType",e);static getAllTypes=async()=>await m("Rpc","getAllTypes");static getAllConnections=async()=>await m("Rpc","getAllConnections");static getRegistrations=async(e=!1)=>await m("Rpc","getRegistrations",e);static evalObject=async e=>await m("Rpc","evalObject",e);static evalString=async e=>await m("Rpc","evalString",e);static listenCalls=()=>m("Rpc","listenCalls");static root=we;static type=O;static exists=q;static getMethods=I;static getObjectMethods=e=>(typeof e=="string"?k(e):e)[I]();static getObjectExists=e=>(typeof e=="string"?k(e):e)[q]();static getObjectType=e=>e[O]}const dt=Object.freeze(Object.defineProperty({__proto__:null,CustomDynamicType:Ie,DataInput:ye,DataOutput:M,PendingCall:re,RPC_ROOT:we,Rpc:C,RpcCallError:z,get RpcConnectionError(){return exports.RpcConnectionError},RpcCustomError:L,get RpcDataError(){return exports.RpcDataError},RpcError:b,get RpcEvalError(){return exports.RpcEvalError},RpcFunction:S,get RpcMetaMethodNotFoundError(){return exports.RpcMetaMethodNotFoundError},get RpcMethodNotFoundError(){return exports.RpcMethodNotFoundError},RpcObjectExists:q,RpcObjectGetMethods:I,RpcObjectType:O,RpcProvider:Be,get RpcTypeNotFoundError(){return exports.RpcTypeNotFoundError},createRemoteObject:k,getAsyncIterator:X,listenersMap:A,pendingMap:$,registerFunction:ne,registerReceive:Q,rejectCall:v,resolveCall:P,runReceiveMessage:W,unregisterFunction:ie},Symbol.toStringTag,{value:"Module"}));exports.CustomDynamicType=Ie;exports.DataInput=ye;exports.DataOutput=M;exports.PendingCall=re;exports.RPC_ROOT=we;exports.Rpc=C;exports.RpcCallError=z;exports.RpcCustomError=L;exports.RpcError=b;exports.RpcFunction=S;exports.RpcObjectExists=q;exports.RpcObjectGetMethods=I;exports.RpcObjectType=O;exports.RpcProvider=Be;exports.createRemoteObject=k;exports.getAsyncIterator=X;exports.listenersMap=A;exports.pendingMap=$;exports.registerFunction=ne;exports.registerReceive=Q;exports.rejectCall=v;exports.resolveCall=P;exports.runReceiveMessage=W;exports.unregisterFunction=ie;
//# sourceMappingURL=rpc.cjs.map
